## 📝 TIL 
📖 오늘 읽은 범위 : 4장.객체

 > 😄 **책에서 기억하고 싶은 내용을 써보세요.**
 
 ### 4.1 객체 타입  
 {...} 구문을 사용해서 객체 리터럴을 생성하면, 타입 스크립트는 해당 속성을 기반으로 새로운 객체 타입 또는 타입 형태를 고려한다.  
 해당 객체 타입은 객체의 값과 동일한 속성명과 원시 타입을 갖는다.  
 null과 undefined를 제외한 모든 값은 그 값에 대한 실제 타입의 멤버 집합을 가지므로 타입스크립트는 모든 값의 타입을 확인하기 위해 객체 타입을 이해해야 한다.
 
 #### 4.1.1 객체 타입 선언
 객체 타입은 필드 값 대신 타입을 사용해 설명한다. 타입스크립트가 타입 할당 가능성에 대한 오류 메시지에 표시하는 것과 동일한 구문이다.
 
 ```typescript
  let poetLeter: {
    born: number;
    name: string;
  };
  poetLeter = {
    born: 1935,
    name: "Mary Oliver",
  };
 ```
 
 #### 4.1.2 별칭 객체 타입
 타입스크립트의 할당 가능성 오류 메시지를 좀 더 직접적으로 읽기 쉽게 만드는 추가 이점이 있다.
 
 ```typescript
 type Poet = {
  born: number;
  name: string;
 };
 ```
 
 ### 4.2 구조적 타이핑
 타입 시스템은 구조적으로 타입화(structurally typed)되어 있다.  
 즉, 타입을 충족하는 모든 값을 해당 타입의 값으로 사용할 수 있다.  
 매개 변수나 변수가 특정 객체 타입으로 선언되면 타입스크립트에 어떤 객체를 사용하든 해당 속성이 있어야 한다고 말해야 한다.  
 
 구조적 타이핑은 덕 타이핑(duck typing)과는 다르다.
 덕 타이핑은 '오리처럼 보이고 오리처럼 꽥꽥거리면, 오리일 것이다'라는 문구에서 유래된 것으로, 동적 타이핑의 한 종류이며, 객체의 변수 및 메서드의 집합이 객체의 타입을 결정하는 것을 의미한다.
 
 - 타입스크립트의 타입 검사기에서 **구조적 타이핑은 정적 시스템이 타입을 검사하는 경우**이다.
 - **덕 타이핑은 런타임에서 사용될 때까지 객체 타입을 검사하지 않는 것**을 말한다.

요약하면 자바스크립트는 덕 타입(duck typed)인 반면 타입스크립트는 구조적으로 타입화된다.

#### 4.2.1 사용 검사
객체 타입으로 애너테이션된 위치에 값을 제공할 때 타입스크립트는 값을 해당 객체 타입에 할당할 수 있는지 확인한다.
객체 타입에 필요한 멤버가 객체에 없다면 타입스크립트는 타입 오류를 발생시킨다.

#### 4.2.2 초과 속성 검사
변수가 객체 타입으로 선언되고, 초깃값에 객체 타입에서 정의된 것보다 많은 필드가 있다면 타입스크립트에서 타입 오류가 발생한다.
초과 속성 검사는 객체 타입으로 선언된 위치에서 생성되는 객체 리터럴에 대해서만 일어난다. 기존 객체 리터럴을 제공하면 초과 속성 검사를 우회한다.

#### 4.2.3 중첩된 객체 타입
자바스크립트 객체는 다른 객체의 멤버로 중첩될 수 있으므로 타입스크립트의 객체 타입도 타입 시스템에서 중첩된 객체 타입을 나타낼 수 있어야 한다.
이를 구현하는 구문은 기본 이름 대신에 {...} 객체 타입을 사용한다.

```typescript
type Poem = {
  author: {
    firstName: string;
    lastName: string;
  };
  name: string;
};

type Author = {
  firstName: string;
  lastName: string;
};

type Poem = {
  author: Author;
  name: string;
};
```

#### 4.2.4 선택적 속성
타입의 속성 애너테이션에서 : 앞에 ?를 추가하면 선택적 속성임을 나타낼 수 있다.

### 4.3 객체 타입 유니언
#### 4.3.1 유추된 객체 타입 유니언
객체 타입이 여러 객체 타입 중 하나가 될 수 있는 상황일 때, 초깃값을 주면 타입스크립트가 이를 검사하여 해당 객체의 타입을 객체 타입 유니언으로 유추한다.

#### 4.3.2 명시된 객체 타입 유니언
명시적으로 객체 타입을 정의하는 것.

#### 4.3.3 객체 타입 내로잉
타입 검사기가 유니언 타임 값에 특정 속성이 포함된 경우에만 코드 영역을 실행할 수 있음을 알게 되면, 값의 타입을 해당 속성을 포함하는 구성 요소로만 좁힌다.  
코드에서 객체의 형태를 확인하고 타입 내로잉이 객체에 적용된다.
```typescript
  if('pages' in poem) { ... }
```

#### 4.3.4 판별된 유니언(discriminated union)
객체의 속성이 객체의 형태를 나타내도록 하는 것.
타입 형태를 판별된 유니언이라 부르고, 객체의 타입을 가리키는 속성이 판별값이다. 타입스크립트는 코드에서 판별 속성을 사용해 타입 내로잉을 수행한다.

### 4.4 & 교차타입(intersaction type)
여러 타입을 동시에 나타내는 것  
여러 기존 객체 타입을 별칭 객체 타입으로 결합해 새로운 타입을 생성하는 것  
교차 타입은 유니언 타입과 결합할 수 있다.

#### 4.4.1 교차 타입의 위험성
스스로나 컴파일러를 혼동시킬 수 있다.
코드를 간결하게 유지해야 한다.

##### 긴 할당 가능성 오류
- 유니언 타입과 결합하는 것처럼 복잡한 교차 타입을 만들게 되면 할당 가능성 오류 메시지가 읽기 어려워진다.
- 타입을 일련의 별칭으로 분할하여 작성하면 읽기가 훨씬 쉬워진다.

##### never
원시 타입의 값은 동시에 여러 타입이 될 수 없기 떄문에 교차 타입의 구성 요소로 결합할 수 없다.
이를 시도하면 never 키워드로 표시되는 never 타입이 된다.
never 키워드와 never 타입은 bottom 타입 또는 empty 타입을 뜻한다. bottom 타입은 값을 가질 수 없고 참조할 수 없는 타입이므로 bottom 타입에 그 어떠한 타입도 제공할 수 없다.
코드에서 불가능한 상태를 나타내기 위해 가끔 등장한다.

 > 🤔 **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**  
마침 잠깐 오늘 잠깐 튼 영상에서 never에 대해 조금 나왔는데, 조금 정리하자면..  
never는 공집합이다. never를 코드에 직접 작성하면 실행하지 않는다.  
그치만 [] 를 감싸면 코드 상에 사용이 가능하다.
boolean의 부분집합이라고도 하는데.. 요런 개념으로 생각해본 적이 없어서 역시 여러 방면으로 볼 수 있는 시야가 있음 좋겠다라고 생각했다.
타입에선 never에서 오류가 나는 부분이 많다고 하니까 이건 기억해둬야겠다.
 
