# 📖 오늘 읽은 범위 : 14장. 구문 확장

## 😄 책에서 기억하고 싶은 내용을 써보세요

오늘날, 타입스크립트와 같은 상위 집합 언어에 특정 새로운 런타임 기능으로 자바스크립트 구문을 확장하는 방식은 다음과 같은 이유로 인해 나쁜 사례로 간주한다.

- 런타임 구문 확장이 최신 버전 자바스크립트의 새로운 구문과 충돌할 수 있다는 점이 가장 중요하다.
- 언어를 처음 접하는 프로그래머가 자바스크립트가 끝나는 곳과 다른 언어가 시작하는 곳을 이해하기 어렵게 만든다.
- 상위 집합 언어 코드를 사용하고 자바스크립트를 내보내는 트랜스파일러의 복잡성을 증가시킨다.

타입스크립트가 자바스크립트의 구문을 확장한 경우가 세 가지가 존재하는데, 클래스, 열거형(enum), 네임스페이스이다.  
클래스는 자바스크립트의 클래스와 거의 동일하게 보이고 작동하며, 열거형은 유용한 경우가 있어 일부 프로젝트에서 여전히 사용된다. 네임스페이스는 새로운 프로젝트에서 사용되지 않는다.  
타입스크립트는 자바스크립트의 데코레이터(decorator)에 대한 실험적 제안(experimental proposal)을 채택했다.

| 데코레이터(decorator) : 새 함수를 반환하여 전달된 함수 또는 메서드의 동작을 수정하는 함수

### 14.1 클래스 매개변수 속성

- 클래스를 많이 사용하는 프로젝트나 클래스 이점을 갖는 프레임워크가 아니라면 클래스 매개변수 속성을 사용하지 않는 것이 좋다.

```typescript
class Engineer {
  readonly area: string;

  constructor(area: string) {
    this.area = area;
    console.log(`I work in the ${area} area.`);
  }
}
new Engineer('mechanical').area;
```

위 코드를 매개변수 속성을 사용해서 재작성한 코드

```typescript
class Engineer {
  constructor(readonly area: string) {
    console.log(`I work in the ${area} area.`);
  }
}
new Engineer('mechanical').area;
```

타입스크립트는 이러한 종류의 매개변수 속성(parameter property)을 선언하기 위한 단축 구문을 제공한다.
속성은 클래스 생성자의 시작 부분에 동일한 타입의 멤버 속성으로 할당된다.
생성자의 매개변수 앞에 readonly 또는 public, protected, private 제한자 중 하나를 배치하면 타입스크립트가 동일한 이름과 타입의 속성도 선언하도록 지시한다.

매개변수 속성은 클래스 생성자의 맨 처음에 할당된다. 또한, 다른 매개변수 또는 클래스 속성과 혼합될 수 있다.

```typescript
class NamedEngineer {
  fullName: string; // 일반속성

  constructor(
    name: string, // 일반 매개변수
    public area: string // 매개변수 속성
  ) {
    this.fullName = `${name}, ${area} engineer`;
  }

  print() {
    console.log(this.fullName);
    console.log(this.area);
  }
}

class NamedEngineer2 {
  // 매개변수 속성을 사용하지 않고 재정의한 클래스
  fullName: string;
  area: string;

  constructor(name: string, area: string) {
    this.area = area;
    this.fullName = `${name}, ${area} engineer`;
  }

  print() {
    console.log(this.fullName);
    console.log(this.area);
  }
}

new NamedEngineer('saem', 'korea').print();
new NamedEngineer2('saem', 'korea').print();
```

매개변수 속성은 타입스크립트 커뮤니티에서 가끔 논의되는 주제이다. 대부분의 프로젝트는 런타임 구문 확장이므로 앞에서 언급했던 단점으로 인해 어려움을 겼기 때문에 매개변수를 완전히 사용하지 않는 것을 선호한다.
또한 매개변수 속성은 새로운 # 클래스 private 필드 구문과 함께 사용할 수 없다.  
반면, 클래스 생성을 매우 선호하는 프로젝트에서는 매개변수 속성을 사용하면 좋다. 매개변수 속성은 매개변수 속성 이름과 타입을 두 번 선언해야 하는 편의 문제를 해결하는데, 이 선언은 타입스크립트 고유의 것이다.

### 14.2 실험적인 데코레이터

데코레이터 함수는 @와 함수 이름을 먼저 배치해 클래스와 멤버에 주석을 달 수 있도록 하는 자바스크립트를 위한 제안이다.

```typescript
@myDecorator
class MyClass {
  /* ... */
}
```

실험적인 데코레이터는 experimentalDecorators 컴파일러 옵션을 제공한다. tsconfig 파일을 통해 활성화할 수 있다.

데코레이터의 각 사용법은 데코레이팅하는 엔티티가 생성되자마자 한 번 실행된다. 각 종류의 데코레이터(접근자, 클래스, 메서드, 매개변수, 속성)는 데코레이팅하는 엔티티를 설명하는 서로 다른 인수 집합을 받는다.

### 14.3 열거형

자주 반복되는 리터럴 집합이 있고, 그 리터럴 집합을 공통 이름으로 설명할 수 있으며, 열거형으로 전환했을 때 훨씬 더 읽기 쉽지 않은 경우라면 열거형을 사용해서는 안 된다.

열거형은 각 값에 대해 친숙한 이름을 사용한 객체에 저장된 리터럴 값 집합으로 생각할 수 있다.

컴파일된 자바스크립트에서 열거형은 이에 상응하는 객체로 컴파일된다. 열거형의 각 멤버는 해당 값을 갖는 객체 멤버 키가 되고 그 반대의 겨웅도 마찬가지이다.

열거형은 '자바스크립트에 새로운 런타임 구문 구조를 절대 추가하지 않는다'는 타입스크립트의 일반적인 만트라(mantra)를 위반한다.

#### 14.3.1 자동 숫자값

열거형의 멤버는 명시적인 초깃값을 가질 필요가 없다. 값이 생략되면 타입스크립트는 첫번째 값을 0으로 시작하고 각 후속 값을 1씩 증가시킨다.

#### 14.3.2 문자열값을 갖는 열거형

열거형의 멤버로 숫자 대신 문자열 값을 사용할 수 있다.
읽기 쉬운 이름으로 공유 상수의 별칭을 지정하는 데 유용하다.
다만, 타입스크립트에 따라 자동으로 계산할 수 없다는 단점(숫자처럼 1씩 증가하는)을 가지고 있다.

#### 14.3.3 const 열거형 (const enum)

열거형은 런타임 객체를 생성하므로 리터럴 값 유니언을 사용하는 일반적인 전략보다 더 많은 코드를 생성한다. 타입스크립트는 const 제한자로 열거형을 선언해 컴파일된 자바스크립트 코드에서 객체 정의와 속성 조회를 생략하도록 지시한다.

```typescript
const enum DisplayHint {
  Opaque = 0,
  Semitransparent,
  Transparent,
}

let displayHint = DisplayHint.Transparent;
```

컴파일 된 자바스크립트 코드에는 열거형 선언이 모두 누락되고 열거형의 값에 대한 주석을 사용한다.

```javascript
let displayHint = 2; /* DisplayHint.Transparent */
```

열거형 객체 정의를 생성하는 것이 여전히 바람직한 프로젝트라면 열거형 정의 자체가 존재하도록 만드는 preserveConstEnums 컴파일러 옵션을 사용한다. 여전히 열거형 객체에 접근하는 대신 리터럴을 직접 사용한다.
preserveConstEnums는 생성된 자바스크립트 코드의 크기를 줄이는 데 유용하지만 타입스크립트 코드를 변환하는 모든 방법이 이를 지원하는 것은 아니다.

### 14.4 네임스페이스

- 기존 패키지에 대한 DefinitelyTyped 타입 정의를 작성하지 않는 한 네임스페이스를 사용하지 마라.

ECMA스크립트 모듈이 사용되기 전 내부 모듈 개념을 가진 네임스페이스를 제공하였다.

네임스페이스로 구조화된 타입스크립트 코드는 웹팩과 같은 최신 빌더에서 사용하지 않는 파일을 제거하는 것이 쉽지 않다. 네임스페이스는 ECMA 스크립트 모듈처럼 파일 간에 명시적으로 선언되는 게 아니라 암시적으로 연결을 생성하기 떄문이다. 따라서, 타입스크립트 네임스페이스가 아닌 ECMA스크립트 모듈을 사용해 런타임 코드를 작성하는 것이 훨씬 좋다.

### 14.5 타입 전용 가져오기와 내보내기

타입스크립트의 트랜스파일러는 자바스크립트 런타임에서 사용되지 않으므로 파일의 가져오기와 내보내기에서 타입 시스템에서만 사용되는 값을 제거한다.
한 번에 하나의 파일에서 작동하는 바벨 같은 트랜스파일러는 각 이름이 타입시스템에서만 사용되는지 여부를 알 수 있는 타입스크립트 타입 시스템에 접근할 수 없다.
타입스크립트의 isolatedModules 컴파일러 옵션은 코드가 타입스크립트가 아닌 다른 도구에서 변환되는지 확인할 때 매우 유용하다.

타입스크립트는 export와 import 선언에서 개별적으로 가져온 이름 또는 전체 { ... } 객체 앞에 type 제한자를 추가할 수 있다. 이렇게 하면 타입 시스템에서만 사용된다는 것을 나타낸다. 패키지의 기본 가져오기를 type으로 표시할 수 있다.

```typescript
import { type TypeOne, value } from 'my-example-types';
import type { TypeTwo } from 'my-example-types';
import type DefaultType from 'my-example-types';

export { type TypeOne, value };
export type { DefaultType, TypeTwo };
```

가져오기가 타입 전용으로 표시된 경우, 이를 런타임으로 사용하려고 하면 타입스크립트 오류가 발생한다.
내보내진 자바스크립트에 복잡성을 더하는 대신, 타입 전용 가져오기와 내보내기는 코드 일부를 제거할 수 있을 떄 타입스크립트 외부의 트랜스파일러에 명확하게 알린다.

따라서 대부분의 타입스크립트 개발자는 이번 장에서 다룬 구문 확장에 대한 거부감으로 인해 타입 전용 가져오기와 내보내기를 잘 사용하지 않는다.

## 🔎 **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**

> ECMA 스크립트 버전이 데코레이터 구문으로 승인될 때까지 가능하면 데코레이터를 사용하지 않는 것이 좋다. 타입스크립트 데코레이터 사용을 권장하는 앵귤러나 Nest.JS 와 같은 프레임워크 버전에서 작업하는 경우 프레임워크 설명서에서 데코레이터를 사용하는 방법을 알려준다.

책이 나올 시점엔 아마도 버전 4.7.2이었던 것 같다. 5.0 버전에 데코레이터 기능이 나온 것을 확인하였다.
아직 제안이 진행중이지만 기능으로, 브라우저에서는 지원하지 않지만, 여러 트랜스파일러 도구에서 사용이 가능하다고 하다.
더이상 experimentalDecorators 옵션을 지정하지 않아도 되며, 실험적 데코레이터와 다르게 타입이 체크되며 출력될 것이다.

**참고글**

- TypeScript 5.0 번역
  (<https://velog.io/@hustle-dev/TypeScript-5.0-%EB%B2%88%EC%97%AD>)
- Decorators
  (<https://runebook.dev/ko/docs/browser_support_tables/decorators>)
