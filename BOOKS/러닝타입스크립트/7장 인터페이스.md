# 📖 오늘 읽은 범위 : 7장.인터페이스
## 😄 책에서 기억하고 싶은 내용을 써보세요.

인터페이스는 별칭으로 된 객체 타입과 여러 면에서 유사하지만 일반적으로 더 읽기 쉬운 오류 메시지, 더 빠른 컴파일러 성능, 클래스와의 더 나은 상호 운용성을 위해 선호된다.

### 7.1 타입 별칭 vs 인터페이스
인터페이스에 대한 타입스크립트의 할당 가능성 검사와 오류 메시지는 객체 타입에서 실행되는 것과 거의 동일하다.
그러나 인터페이스와 타입 별칭 사이에는 몇 가지 주요 차이점이 있다.
- 인터페이스는 속성 증가를 위해 병합(merge) 할 수 있다. 내장된 전역 인터페이스 또는 npm 패키지와 같은 외부 코드를 사용할 때 특히 유용하다.
- 인터페이스는 클래스가 선언된 구조의 타입을 확인하는 데 사용할 수 있지만 타입 별칭은 사용할 수 없다.
- 일반적으로 인터페이스에서 타입스크립트 타입 검사기가 더 빨리 작동한다. 인터페이스는 타입 별칭이 하는 것처럼 새로운 객체 리터럴의 동적인 복사 붙여넣기보다 내부적으로 더 쉽게 캐시할 수 있는 명명된 타입을 선언한다.
- 인터페이스는 이름 없는 객체 리터럴의 별칭이 아닌 이름 있는(명명된) 객체로 간주되므로 어려운 특이 케이스에서 나타나는 오류 메시지를 좀 더 쉽게 읽을 수 있다.

타입 별칭의 유니언 타입과 같은 기능이 필요할 때까지는 인터페이스를 사용하는 것이 좋다.

### 7.2 속성 타입
`readonly` 키워드 - 인터페이스에 정의된 객체의 속성을 재할당하지 못하도록 하는 키워드

#### 인터페이스 멤버를 함수로 선언하는 두 가지 방법
1. **메서드 구문** : 인터페이스 멤버를 `member(): void`와 같이 객체의 멤버로 호출되는 함수로 선언
2. **속성 구문** : 인터페이스의 멤버를 `member: () => void`와 같이 독립 함수와 동일하게 선언

**주요 차이점**
- 메서드는 readonly 로 선언할 수 없지만 속성은 가능하다.
- 인터페이스 병합은 메서드와 속성을 다르게 처리한다.
- 타입에서 수행되는 일부 작업은 메서드와 속성을 다르게 처리한다.

=> 결론
- 기본 함수가 this를 참조할 수 있다는 것을 알고 있다면 메서드 함수를 사용하라. 가장 일반적으로 클래스의 인스턴스에서 사용된다.
- 반대의 경우는 속성 함수를 써라.

#### 호출 시그니처 (call signature)
호출 시그니처는 값을 함수처럼 호출하는 방식에 대한 타입시스템의 설명이다. 호출 시그니처가 선언한 방식으로 호출되는 값만 인터페이스에 할당할 수 있다.  
즉, 할당 가능한 매개변수와 반환 타입을 가진 함수이다. 호출 시그니처는 함수 타입과 비슷하지만, 콜론(:) 대신 화살표(=>)로 표시한다.

#### 인덱스 시그니처 (index signature)
인터페이스의 객체가 임의의 키를 받고, 해당 키 아래의 특정 타입을 반환할 수 있음을 나타낸다. 자바스크립트 객체 속성 조회(lookup)는 암묵적으로 키를 문자열로 변환하기 때문에 인터페이스의 객체는 문자열 키와 함께 가장 일반적으로 사용된다.
인덱스 시그니처는 일반 속성 정의와 유사하지만 키 다음에 타입이 있고 `[i: string] : ...`과 같이 배열의 대괄호를 갖는다.  
인덱스 시그니처는 객체에 값을 할당할 때 편리하지만 타입 안정성을 완벽하게 보장하지는 않는다. 인덱스 시그니처는 객체가 어떤 속성에 접근하든 간에 값을 반환해야 함을 나타낸다.
키/값 쌍을 저장하려고 할 때 키를 미리 알 수 없다면 Map을 사용하는 편이 더 안전하다.

### 7.3 인터페이스 확장
확장할 인터페이스의 이름 뒤에 `extend` 키워드를 추가해서 다른 인터페이스를 확장할 수 있다.

#### 7.3.1 재정의된 속성
속성을 재선언하는 대부분의 파생 인터페이스는 해당 속성을 유니언 타입의 더 구체적인 하위 집합으로 만들거나 속성을 기본 인터페이스의 타입에서 확장된 타입으로 만들기 위해 사용한다.

```typescript
  interface WithNullableName {
    name: string | null;
  }
  
  interface WithNonNullableName extends WithNullableName {
    name : string;
  }
```

#### 7.3.2 다중 인터페이스 확장
extends 키워드 뒤에 쉼표로 인터페이스 이름을 구분해 사용하면 된다.

### 7.4 인터페이스 병합
두 개의 인터페이스가 동일한 이름으로 동일한 스코프에 선언된 경우, 선언된 모든 필드를 포함하는 더 큰 인터페이스가 코드에 추가된다.

#### 7.4.1 이름이 충돌되는 멤버 
병합된 인터페이스는 타입이 다른 동일한 이름의 속성을 여러 번 선언할 수 없다. 속성이 이미 인터페이스에 선언되어 있다면 나중에 병합된 인터페이스에서도 동일한 타입을 사용해야 한다.
병합된 인터페이스는 동일한 이름과 다른 시그니처를 가진 메서드는 정의할 수 있다.

## 🤔 오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요
타입 별칭과 인터페이스의 차이점이 별로 없는 걸로 알고 있어서 객체 타입을 선언할 때 인터페이스를 선언하는 걸로만 생각을 하고 있었는데, 생각보다 더 많은 부분을 알 수 있었던 것 같다.
흥미로운 챕터였다.
