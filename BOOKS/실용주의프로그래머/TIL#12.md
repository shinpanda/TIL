## 📝 TIL (2022.04.03)
## Day 16 
📖 오늘 읽은 범위 : 6장.코딩하는 동안 해야 할 일들

 > 😄 **책에서 기억하고 싶은 내용을 써보세요.**
- 적극적으로 자기 코드에 생각하지 않는 프로그래머는 우연에 맡기는 프로그래밍(programming by coincidence)를 하는 것이다.
- ### 우연에 맡기는 프로그래밍
  - 우연에 맡기는 프로그래밍, 곧 행운과 어쩌다 오는 성공에 의존하는 프로그래밍을 하지 말아야 한다. 대신 의도적으로 프로그래밍(programming deliberately)해야 한다.
  - #### 우연적 구현(accidents of implementation)
    - 단순히 코드가 지금 작성된 방식이 그렇기 때문에 생기는 일을 가리킨다. 결국에는 문서화되지 않은 에러나 입력값이 특정한 조건에서만 돌아가는 경우와 마주치게 된다.
    - 문서화되지 않은 동작은 라이브러리의 다음 릴리스에서 변경될 가능성이 있다.
    - 불필요한 추가 호출은 코드를 더 느리게 만든다.
    - 추가로 호출한 루틴 때문에 새로운 버그들이 코드에 들어올 가능성이 있다.
    - 다른 사람들이 호출할 코드를 작성할 때는 모듈화를 잘하거나 문서화가 잘 된 작은 규모의 인터페이스 아래에 구현을 숨기는 것과 같은 기본 원칙들이 모두 도움이 된다.
  - #### 우연적 맥락(accidents of context)
    - 확실한 것이 아닌데도 의존하고 있는 다른 것들은 어떤 것이 있을까?
  - #### 암묵적인 가정
    - 확고한 사실에 근거하지 않은 가정은 어떤 프로젝트에서든 재앙의 근원이 된다.
    - 우연에 맡기는 프로그래밍을 하지 말라.
  - #### 의도적으로 프로그래밍하기
    - 언제나 자기가 지금 무엇을 하고 있는지 알아야 한다.
    - 맹목적으로 코딩하지 말라. 완전하게 이해하지 못한 애플리케이션을 빌드하려 하거나 익숙하지 않은 기술을 사용하려고 시도하는 행동은 우연에게 자기를 미혹해도 좋다는 초청장을 보내는 것과 다름없다.
    - 계획을 세우고 그것을 바탕으로 진행하라. 머리 속에 있는 계획이든, 냅킨 뒤에 적어놓은 계획이든, CASE 도구로 만든 한쪽 벽면에 가득 찰 정도 계획이든 상관없다.
    - 신뢰할 수 있는 것에만 기대라. 어떤 상황에서 신뢰할 만한 것과 아닌 것을 판단하지 못하겠거든, 일단 가장 최악의 상황을 가정하라.
    - 가정을 문서로 남겨라.
    - 어떤 일이든 단지 추축만 하지 말고 실제로 시험해 보도록 하자.
    - 노력을 기울일 대상의 우선순위를 정하라. 기반(fundamental) 또는 인프라(infrastructure)가 올바르지 않다면 현란한 부가 기능들도 다 소용없다.
    - 과거의 노예가 되지 말라. 기존 코드가 앞으로 짤 코드를 지배하도록 놓아두지 말라.
- ### 알고리즘의 속도
  - #### O() 표기법
    - O() 표기법은 우리가 측정하는 것(시간, 메모리, 기타 등등)의 상한값을 정하는 표기법이다.
    - O() 표기법은 시간에만 적용되지 않으며, 알고리즘이 사용하는 다른 어떤 자원(resource)을 나타낼 때도 이 표기법을 이 표기법을 이용할 수 있다.
  - #### 상식적인 추정
    - 간단한 반복문(loop) - 만약 간단한 반복문 하나가 1부터 n까지 돌아간다면, 이 알고리즘이 O(n)일 가능성이 높다. 즉 수행시간은 n과 비례해서 증가한다.
    - 겹친 반복문 - 알고리즘은 O(m * n) 이런 정렬 알고리즘은 O(n2)이 되기 쉽다.
    - 반씩 잘라 나가기 - O(lg(n)이 될 가능성이 높다
    - 나눠서 정복하기(divide and conquer) - 퀵정렬. 데이터를 반으로 나누고 각 반쪽에서 재귀적으로 정렬을 수행한다.
    - 조합적(combinatoric) - 순열은 계승(factorial) 이 관련되기 떄문에, 알고리즘이 항목의 순열을 다루기 시작하면 거의 대부분의 수행시간이 걷잘을 수 없이 늘어난다. 종종 한정된 문제 도메인에서 이런 종류의 알고리즘의 수행시간을 줄이기 위해 휴리스틱이 동원되기도 다.
  - #### 실전에서의 알고리즘 속도
    - 숫자가 외부 요인에 따라 달라진다면, 잠시 작업을 멈추고 커다란 수가 들어왔을 경우, 수행시간이나 메모리 소비에 어떤 영향을 미칠지 생각해 보는 것이 좋다.
    - 알고리즘의 차수를 추정하라.
    - O(n2) 알고리즘이 있다면 O(nlg(n))으로 줄이기 위해 나누어 정복하는 (divide and conquer) 방법을 찾을 수 있는 지 시도해 본다.
    - 코드의 실행시간이 얼마나 될지, 또는 메모리를 얼마나 사용할지 확실하지 않다면, 입력 레코드의 수나 혹은 런타임에 영향을 줄 것이라고 생각되는 어떤 요소든 바꾸어 가면서 직접 실행해보라. 그런 다음 결과를 그래프로 그려본다.
    - 추정을 이미 했다고 하더라도, 현장에서 실제 데이터를 입력받아 돌아가는 코드의 수행시간만이 정말로 의미있는 수치다.
    - 추정을 테스트하라.
    - 정확하게 시간을 재는 일이 어렵다면, 코드 프로파일러(code profiler)를 사용해서 알고리즘이 돌아갈 때 실행되는 각 단계의 반복 회수를 센 다음, 입력값의 규모를 바꿔 가면서 나오는 값을 그래프로 그린다.
  - #### 최고라고 언제나 최고는 아니다.
    - 성급한 최적화(premature optimization)를 조심하라.
- ### 리팩터링
  - 코드를 다시 작성하기, 다시 작업하기, 다시 설계하기는 총괄해서 '리팩터링(refactoring)이라고 알려져 있다.
  - #### 리팩터링은 언제 해야 하는가?
    - 코드가 더 이상 잘 맞지 않아서 장애물에 부딪혔을 때, 사실은 하나로 합쳐져야 할 두 개를 발견했을 때, 어떤 것이든 '잘못'되었다고 생각될 때
    - 중복 - DRY 원칙 위반
    - 직교성이 좋지 않은 설계
    - 유효기간이 끝난 지식 - 코드는 지금 상황에 뒤떨어지지 않게 유지되어야 한다.
    - 성능
    - 코드를 리팩터링하는 것 - 기능을 이리저리 옮기고 이전에 내린 결정을 갱신하는 것 -은 사실 고통 관리(pain management)를 실천하는 것이다.
  - #### 현실 세계의 복잡한 문제들
    - 일찍 리팩터링하고, 자주 리팩터링하라.
    - 리팩터링해야 할 것들의 명단을 만들고 유지하라.
  - #### 리팩터링은 어떻게 하는가?
    - 리팩터링의 본질은 재설계다.
    - 설계된 모든 것은 새로운 사실이 밝혀지거나 문제에 대한 이해가 더 깊어지거나 요구사항이 바뀌는 것과 같은 일이 생긴다면, 언제라도 재설계의 대상이 될 수 있다.
    - 리팩터링은 천천히. 신중하게, 조심스럽게 진행해야 하는 작업이다.
    - 리팩터링과 새로운 기능 추가를 동시에 하지 말라.
    - 리팩터링을 시작하기 전 든든한 테스트 집합이 있는지 먼저 확인한다. 할 수 있는 한 자주 테스트들을 돌려본다.
    - 단계를 작게 나누어서 신중하게 작업한다. 필드를 한 클래스에서 다른 클래스로 옮기기, 비슷한 메서드를 합쳐서 수퍼클래스로 옮기기. 단계를 작게 나누고, 한 단계가 끝날 때마다 테스트를 돌린다면, 기나긴 시간의 디버깅 작업을 피할 수 있다.
    - 탄탄한 회귀 테스트 집합을 유지하는 것이야 말로 확신을 가지고 리팩터링하기 위한 비결이라는 것이 마틴 파울러가 지적한 요점이다.
    - 모듈의 큰 변화가 있다면, 즉 모듈의 인터페이스나 기능을 이전과 호환성을 유지할 수 없을 정도로 변경하는 변화가 있다면, 일부러 빌드를 실패하도록 변화를 주는 기법도 유용하다.
- ### 테스트하기 쉬운 코드
  - 테스트 가능성이 높은 코드는 디자인이 좋다. 재미있게도, 디자인을 잘 만들려고 할 때보다 테스트 가능성을 높이려고 했을 때 결과 코드의 디자인이 더 나은 경우가 많다.
  - 소프트웨어 단위 테스트란 어떤 모듈에게 이것저것을 시켜보는 코드를 가리킨다.
  - 단위테스트는 일종의 인위적인 환경을 구착한 다음, 테스트할 모듈의 루틴들을 호출한다. 그런 다음 반환된 결과들을 이미 알고 있는 값과 비교해 보거나 똑같은 테스트를 이전에 돌렸을 때 나온 값과 비교해 보아서 (회귀 테스트regression testing) 올바른지 검사한다.
  - 하나의 단위(unit) 차원에서는 어떤 것을 테스트해야 할지 우리는 결정해야 한다.
  - #### 계약을 잘 지키는지 테스트해 보기
    - 테스트를 염두에 두고 설계하라.
    - 모듈을 설계할 때는, 심지어 루틴 하나를 설계할 때도, 그것이 지켜야 할 계약과 계약을 지키는지 테스트하는 코드도 함께 설계해야 한다. 
테스트를 통과하고 계약을 지키는 코드를 설계하다 보면 자연스럽게 그렇게 설계하지 않았으면 생각나지 않았을 경계 조건이나 다른 문제들을 고려하게 된다.
  - #### 단위 테스트 작성하기
    - 단위 테스트는 찾기 편한 곳에 위치하고 있어야 한다.
    - 테스트 코드를 쉽게 접근할 수 있게 해놓는 것은, 매우 귀중한 두 가지 자원을 제공하는 것이다.
      - 모듈의 모든 기능을 어떻게 이용해야 하는지 보여주는 예제
      - 후일 코드 변경시 검증하기 위한 회귀 테스트를 구축할 수 있는 수단
  - #### 테스트 장치(Test Harness)를 사용하기
    - 테스트장치에 필요한 기능
      - 시작할 때 할 일(setup)과 마칠 때 할 일(cleanup)을 지정할 수 있는 표준적인 방법
      - 개별적인 테스트들을 선택하거나, 아니면 모든 테스트를 한꺼번에 선택하게 해주는 메소드
      - 예상한 (또는 예상하지 못한) 결과에 비추어 결과를 분석할 수 있는 방법
      - 실패를 보고하는 표준화된 형태
    - 테스트는 조립식으로 작동할 수 있어야 한다. 즉, 하위 컴포넌트를 테스트하는 하위 테스트들을 조합해서 하나의 테스트를 조립할 수 있어야 하고, 이런 계층 구조의 깊이에는 제한이 없어야 한다.
    - 이를 컴포지트 패턴(composite pattern)이라고 한다.
    - 컴포지트 패턴은 객체들이 부분-전체 구조를 나타내기 위해 트리 구조를 만들어야 하는 상황에서 이요할 수 있는 패턴이다.
  - #### 테스트 문화
    - 소프트웨어를 테스트하라. 그렇지 않으면 사용자가 테스트하게 될 것이다.
- ### 사악한 마법사
  - 대부분 개발은 이제 멀티티어 모델(multitier model)을 사용하며, 여기에 미들웨어 계층이나 트랜잭션 모니터가 붙기도 한다.
  - 자신이 이해하지 못하는, 마법사가 만들어 준 코드는 사용하지 말라.

 > 🤔 **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**  
요새 관심을 가지고 있던 내용이라 흥미롶게 봤던 것 같다. 많은 내용을 얻은 느낌은 아니지만, 더 나아갈 수 있을 때 도움을 얻을 수 있을 것 같다.

 > 🔎 **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**
 
 
