## 📝 TIL (2022.03.27)
## DAY 6
📖 오늘 읽은 범위 : 5장.구부러지거나 부러지거나

 > 😄 **책에서 기억하고 싶은 내용을 써보세요.**
 ### 결합도 줄이기와 디미터 법칙
  - 코드를 세포(모듈, module)로 구성하고, 이들 간의 상호작용을 제한하라. 그러면 한 모듈이 변경되거나 교체된다 하더라도 다른 모듈들은 변경 없이 수행될 수 있을 것이다.
  - #### 결합도 줄이기
    - 직접 객체 간의 관계를 헤집고 다닌다면 의존 관계가 조합적으로 폭발(combinational explosion)하게 될 수 있다.
    - 불필요한 의존이 많은 시스템은 유지보수하기 어렵고, 이로 인해 비용이 많이 들며 시스템 자체가 매우 불안정한 경향이 있다. 
    - 우리는 의존도를 최소화하기 위해 디미터 법칙을 사용하여 메서드, 함수를 설계한다.
  - #### 디미터 함수 법칙
    - *모듈간의 결합도를 최소화 하라.*
    - 한 객체가 제공하는 메서드에 접근하기 위해 또 다른 객체들을 통하는 것을 허용하지 않는다.
  - 응답집합(response set)이 큰 클래스는 작은 클래스보다 에러를 발생시키기 쉽다고 한다. 이때 응답집합은 클래스의 메서드가 직접 호출하는 함수의 수를 의미한다.
  - 디미터 법칙을 따르면 함수를 호출하는 클래스의 응답집합 크기를 줄일 수 있기 때문에 좀 더 에러가 적은 클래스들을 만들 수 있다.
  - 디미터 법칙은 코드를 더 적응성 있고 강하게 만들어 주지만 '주계약자(general contractor)'로서의 대가를 치러야 한다.
  - 위임자에게 단순히 요청을 전달하는 역할만을 하는 간단한 위임 메서드를 상당수 만들어야 함을 의미한다. 이러한 위임 메서드는 성능 저하와 메모리 과부하와 같은 문제를 야기할 수 있다.
  - 데이터베이스 스키마 설계시 '반정규화'를 통해 성능을 개선하는 것처럼 해당 모듈들이 서로 결합하고 있다는 것을 잘 알고, 또 그것을 받아들일 수 있다면 아직 괜찮은 설계라 할 수 있다.
 ### 메타프로그래밍
  - 아무리 뛰어난 천재라도 세부사항에 집착하면 그 재능이 발휘되지 않는 법이다.
  - 세부사항을 코드에서 몰아내라. 이렇게 함으로써 우리의 코드는 매우 설정 가능(configurable)하게 뙤고 '소프트'해진다. 즉, 변화에 쉽게 적응할 수 있게 되는 것이다.
  - ### 동적 설정
    - *통합하지 말고 설정 옵션으로 구현하라.*
    - 시스템을 되도록 설정가능하게 만들기 바란다. 배경 색, 프롬프트 텍스트 뿐 아니라 알고리즘의 선택, 사용할 데이터베이스 제품, 미들웨어 기술, 사용자 인터페이스 스타일 등 시스템의 심층까지 말이다.    
    - 메타데이터(metadata)를 이용하여 반환 매개 변수, 사용자 선호사항, 설치 디렉터리와 같은 애플리케이션 설정 옵션을 기술하라.
    - 메타데이터란, 데이터에 관한 데이터다. 애플리케이션을 기술하는 모든 데이터다.
    - 애플리케이션이 어떻게 시랳ㅇ되어야 하고, 어떤 자원을 이용해야 하는지 등이 기술된다. 이 데이터는 컴파일 타임이 아닌 런타임에 접근, 사용된다.
  - ### 메타데이터 주도 애플리케이션
    - *코드에는 추상화를, 메타데이터에는 세부 내용을.*
    - (어떻게가 아닌 무엇을 해야 하는지를 명시함으로써) 선언적(declarative)으로 생각하는 것이고, 이로써 더 동적이고 적응가능한 프로그램을 만드는 것이 목표이다.
    - 위를 위해 일반적 경우에 대해서 프로그램을 만들고, 특별한 것들은 컴파일된 코드 밖 어딘가에 내높는다.    
    - 이점
      - 설계의 결합도를 줄여 좀 더 유연하고 적응성 있는 프로그램을 만들 수 있다.
      - 세부사항을 코드 밖으로 몰아냄으로써 보다 강하고 추상적인 디자인을 만들 수 있다.
      - 애플리케이션을 커스터마이징하기 위해 다시 컴파일할 필요가 없다. '
      - 메타데이터는 범용 프로그래밍 언어보다 문제 도메인에 가까운 방식으로 표현될 수 있다.
      - 동일한 애플리케이션 엔진과 상이한 메타데이터를 이용해 여러 다른 프로젝트를 진행할 수 있게 된다.
    - 가능한 마지막 순간까지 세부 정의를 피하고, 세부사항을 소프트하게, 변화하기 쉽게 남겨 두라.
  - 비즈니스 로직
    - 비즈니스 정책이나 룰은 프로그램의 다른 어떤 부분보다 변화하기 쉽기 때문에 이를 유연한 포맷을 통해 유지보수하는 것이 좋다.
  - 언제 설정할 것인가?
    - 장시간 동안 수행되는 서버 프로세스를 작성한다면, 프로그램이 실행되는 동안 메타데이터를 리로딩하고 적용할 수 있는 방법을 제공하는 것이 옳다.
    - 빨리 다시 시작할 수 있는 조그만 클라이언트 GUI 애플리케이션이라면, 굳이 실행 중에 설정 정보를 바꾸는 기능까지 제공할 필요는 없을 것이다.
### 시간적 결합 (temporal coupling)
  - 시간에는 우리에게 의미 있는 두 가지 측면이 있다. 동시성(같은 시각에 일어나는 일들)과 순서(시간 속에서 일들의 상대적인 위치)가 그것이다.
  - 이것을 하고, 그런 다음 저것을 하고, 이런 방식으로 생각하다 보면 시간적 결합, 즉 시간 측면에서의 결합을 만들게 된다. 메서드 A는 반드시 메서드 B보다 먼저 호출해야 한다.
  - 우리는 동시성을 허용할 필요가 있고 시간이나 순서에 따른 의존성의 결합을 끊는 방법을 생각할 필요가 있다. 그렇게 함으로써 유연성도 얻을 수 있고, 작업흐름 분석, 아키텍처, 설계, 배치(deploy)와 같은 개발의 여러 측면에서 시간과 관련된 모든 의존성도 줄일 수 있다.
  - #### 작업흐름
    - *서비스를 사용해서 설계하라.*
    - 요구사항 분석의 일부로서 사용자들의 작업흐름을 모델화하고 분석하는 작업이 필요하다.
    - 여기서 원하는 것은 동시에 일어나도 되는 것은 어떤 것이고, 엄격한 순서에 따라 일어나야 하는 것은 어떤 것인지 찾아내는 것이다.
    - UML 활동 다이어그램(UML activity diagram) 같은 표기법을 사용하면 동시에 수행될 수 있지만 아직 그렇지 않은 활동들을 찾아내서 병렬성을 극대화할 수 있다.
    - 작업흐름 분석을 통해 동시성을 개선하라.
    - 배고픈 소비자(hungry consumer) 모델은 중앙 일정 관리자 대신 여러 개의 독립적인 소비자 작업(consumer task)들과 중앙집중식 작업 큐를 사용한다.
각 소비자 작업은 큐에서 하나를 가져가서 그것을 처리하기 시작한다. 개별 컴포넌트들은 자기 속도에 맞추어 일을 진행할 수 있다. 각 컴포넌트들은 서로 시간적으로 결합이 끊기는 것이다.
    - 컴포넌트 대신 서비스를, 잘 정의되고 일관성 있는 인터페이스 뒤에서 일하는 독립적이고 동시적인 객체들을 만든 것이다.
  - #### 동시성을 고려한 설계
    - *언제나 동시성을 고려해 설계하라*
    - 직선형 코드에서는 엄밀하지 않은 프로그래밍으로 이끌리는 전제들을 남발하기 쉽다. 동시성을 염두에 둔다면 이제는 여러 일이 '동시에' 일어날 수 있기 때문에, 갑자기 전에 못 보던 시간에 관련된 의존성들이 보이기 시작한다.
    - 모든 전역 변수나 정적 변수들을 동시 접근으로부터 보호해야 한다. 애초에 왜 전역 변수가 필요했는지 스스로에게 물을 수 있는 좋은 기회다.
    - 호출 순서와 관계없이 일관성 있는 상태 정보를 보일 수 있는지도 확인해 봐야 한다.
    - 호출될 가능성이 있는 모든 시간에 언제나 객체가 유효한 상태에 있도록 만들어야 한다.
  - #### 배치
    - 애플리케이션을 어떻게 배치할 것인지, 곧 독립 애플리케이션으로 할지, 클라이언트-서버로 할지, n-티어로 할지 결정하는 문제에 대해서도 유연하게 대응할 수 있다.
    - 시스템을 독립적인 서비스들로 구성된 아키텍처로 만듦으로써, 설정 역시 동적으로 만들 수 있다.
    - 동시성을 고려해서 계획하고 작업들의 시간적 결합을 끊음으로써, 동시성을 이용하지 않기로 선택한, 독립 애플리케이션을 포함해서 모든 옵션을 다 이용할 수 있게 된다.
### 단지 뷰일 뿐이야
  - 프로그램을 커다란 덩어리 하나로 짜지 말고, '나눠서 정복하기(divide and conquer)' 방법을 써서 여러 모듈로 나누어 짜야 한다.
  - 모듈(또는 클래스)은 '잘 정의된 단 하나의 책임만 가져야 한다.'
  - 여러 다른 객체들의 상태 변화(또는 갱신된 데이터 갑)를 어떻게 동기화해야 할까? 
  - 이벤트를 이용하면 어떤 객체의 상태 변화를 이에 관심을 가질 다른 객체들에게 알릴 수 있으며, 객체들 사이의 결합을 최소화할 수 있다.
이벤트의 전송자는 수신자에 대해 아무런 직접적인 지식을 가질 필요가 없다.
  - #### 모델-뷰-컨트롤러
    - 모델에서 뷰를 분리하라.
### 칠판 (blackboard)
  - *칠판을 사용해 작업흐름을 조율하라.*
  - 칠판 시스템을 이용하면, 지식의 소비자와 생산자들이 익명으로 그리고 비동기적으로 데이터를 주고받는 공간이 생긴다.

 > 🤔 **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**  
오늘은 꽤 유용한 내용들이 많이 나왔다. 항상 동시성을 고려할 것. 결합도를 최소화하고, 설정 옵션으로 구현할 것.
 
 > 🔎 **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**
 
 
