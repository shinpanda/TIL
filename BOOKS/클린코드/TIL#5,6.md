# 📝 TIL (2022.02.22)
## DAY 5,6
📖 오늘 읽은 범위 : 3장.함수
---
> 😄 **책에서 기억하고 싶은 내용을 써보세요.**  

- **작게 만들어라!**  
  함수를 만드는 첫째 규칙은 '작게!'다. 함수를 만드는 둘째 규칙은 '더 작게'다. (p.42)
  
- **블록과 들여쓰기**  
  if 문/else 문/while 문 등에 들어가는 블록은 한 줄이어야 한다는 의미다. 대개 거기서 함수를 호출한다. 그러면 바깥을 감싸는 함수(enclosing function)가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다.  
 이 말은 중첩 구조가 생길 만큼  함수가 커져서는 안 된다는 뜻이다. 그러므로 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안 된다. (p.44)
 
- **한 가지만 해라!**  
 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.(p.44)  
 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다.(p.45)  
 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다.(p.45)  
 
- **함수 당 추상화 수준은 하나로!**  
 근본 개념과 세부사항을 뒤섞기 시작하면, 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.(p.46)
 
- **위에서 아래로 코드 읽기: 내려가기 규칙**  
 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.(p.46)
 
- **Switch문**  
  switch 문은 작게 만들기 어렵다. ... 하지만 각 switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다. 물론 다형성(polyumorphism)을 이용한다.(p.47)  
 
- **서술적인 이름을 사용하라!**  
이름이 길어도 괜찮다. 겁먹을 필요없다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다. 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다. 그런 다음, 여러 단어를 사용해 함수 기능을 잘 표현하는 이름을 선택한다.(p.49)  

- **함수 인수**  
함수에서 이상적인 인수 개수는 0개(무항)다. 다음은 1개(단항)고, 다음은 2개(이항)다. 3개(삼항)은 가능한 피하는 편이 좋다. 4개 이상(다항)은 특별한 이유가 필요하다. 특별한 이유가 있어도 사용하면 안 된다.(p.50)  
출력 인수는 독자가 허둥지둥 코드를 재차 확인하게 만든다.(p.51)

- **많이 쓰는 단항 형식**  
  - 인수에 질문을 던지는 경우 (ex. boolean fileExists("MyFile"))  
  - 인수를 뭔가로 변환해 결과를 반환하는 경우 (ex. InputStream fileOpen("MyFile"))  
  - 이벤트 (ex. passwordAttemptFailedNtimes(int attempts))  
 
- **플래그 인수**  
함수로 부울 값을 넘기는 관례는 정말로 끔찍하다. 왜냐고? 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈이니까! 플래그가 참이면 이걸 하고 거짓이면 저걸 한다는 말이니까!(p.52)  

- **동사와 키워드**  
단항 함수는 함수와 인수가 동사/명사 쌍을 이뤄야 한다. 예를 들어, write(name)은 누구나 곧바로 이해한다. '이름' 이 무엇이든 '쓴다'는 뜻이다. 좀 더 나은 이름은 writeField(name)이다. 그러면 '이름'이 '필드'라는 사실이 분명히 드러난다.  
마지막 예제는 함수 이름에 키워드를 추가하는 형식이다. 즉, 함수 이름에 인수 이름을 넣는다. 예를 들어, assertEquals보다 assertExpectedEqualsActual(expected, actual)이 더 좋다. 그러면 인수 순서를 기억할 필요가 없어진다. (p.54)  

- **부수 효과를 일으키지 마라**  
 때로는 예상치 못하게 클래스 변수를 수정한다. 때로는 함수로 넘어온 인수나 시스템 전역 변수를 수정한다. 어느 쪽이든 교활하고 해로운 거짓말이다. 많은 경우 시간적인 결합이나 순서 종속성을 초래한다. (p.55)  
 만약 시간적인 결합이 필요하다면 함수 이름에 분명히 명시한다. .. 물론 함수가 '한 가지'만 한다는 규칙을 위반하지만.(p.56)  
 
- **출력 인수**  
 일반적으로 출력 인수는 피해야 한다. 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 택한다.(p.56)  
 
- **명령과 조회를 분리하라!**  
set이라는 함수 이름을 setAndCheckIfExists라고 바꾸는 방법도 있지만 if 문에 넣고 보면 여전히 어색하다. 진짜 해결책은 명령과 조회를 분리해 혼란을 애초에 뿌리뽑는 방법이다.(p.57)  
 ```java
 if (attributeExists("username")){
	 setAttribute("username", "unclebob");
 	..
 }
```

- **Try/Catch 블록 뽑아내기**  
try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다. 그러므로 try/catch 블록을 별도 함수로 뽑아내는 편이 좋다.  

- **반복하지 마라(DRY, Don't Repeat Yourself)**  
E. F. 커드는 자료에서 중복을 제거할 목적으로 관계형 데이터베이스에 정규 형식을 만들었다. 객체지향 프로그래밍은 코드를 부모 클래스로 몰아 중복을 없앤다. 구조적 프로그래밍, AOP(Aspect Oriented Programming), COP(Component Oriented Programming) 모두 어떤 면에서 중복 제거 전략이다. (p.60)

- **구조적 프로그래밍**  
 에츠허르 데이크스트라는 모든 함수와 함수 내 모든 블록에 입구와 출구가 하나만 존재해야 한다고 말했다. 즉, 함수는 return 문이 하나여야 한다는 말이다. 루프 안에서 break나 continue를 사용해선 안 되며 goto는 절대로, 절대로 안 된다.  
 함수가 작다면 위 규칙은 별 이익을 제공하지 못한다. 함수가 아주 클 때만 상당한 이익을 제공한다.  
 goto문은 큰 함수에서만 의미가 있으므로, 작은 함수에서는 피해야만 한다.(p.61)  
 
- **결론**  
모든 시스템은 특정 응용 분야 시스템을 기술할 목적으로 프로그래머가 설계한 도메인 특화 언어(Domain Specific Language, DSL)로 만들어진다. 함수는 그 언어에서 동사며, 클래스는 명사다.(p.62)
 
> 🤔 **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**  

오늘 책을 읽으면서 앗 나도 저렇게 구현한 적이 있는데... 하고 계속 반성의 시간을 가지면서 읽었던 시간이 아니었나 싶다.  
때로 오류가 발생했을 때 함수가 너무 쪼개졌다고 타고타고 올라가는 것이 귀찮다고 여겼을 때도 있었는데.. 그게 아니었구나..  
그 전에는 몰랐으니까로 형용되었을지 몰라도 이제 아니까 더 잘해야 할 거 같다.  

> 🔎 **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**  

- 함수가 확실히 '한 가지' 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.(p.46) -> 모든 문장의 추상화 수준이 동일해야 한다? 라는 말이 이해되지 않았다. 사실 추상화 수준이란 말 자체가 이해가지 않았던 것 같다. 아래 블로그를 찾아보니 조금 이해가 되었다.  
하나의 기능을 만드는 것을 추상화라 하는데 이때, 가장 최상위 함수로만 코드가 구성되어 있는 함수의 경우 추상화 수준이 높다고 하며, 구체적인 세부 구현사항을 담은 함수를 추상화 수준이 낮다고 한다. 이러한 함수를 하나로 합친다고 봤을 때, 추상화 수준이 동일하지 않다라고 하는 것같다. 그리고 이렇게 추상화 수준이 높은 것과 낮은 소스가 공존해서는 안된다는 것을 의미하는 것으로 보인다.    
 * 참고
    - https://sosimhan-dev.tistory.com/4
    - https://lordofkangs.tistory.com/m/127
- SRP(Single Responsibility Principle) (p.47) : 단일 책임 원칙. 
  "클래스는 단 한 개의 책임을 가져야 한다." 
  클래스가 여러 책임을 갖게 되면 그 클래스는 각 책임마다 변경되는 이유가 발생하기 때문에 클래스가 한 개의 이유로만 변경되려면 클래스는 한 개의 책임만을 가져야 한다고 한다. 
  이러한 이유로 이 원칙은 다른 말로 "클래스를 변경하는 이유는 단 한 개여야 한다."고도 표현한다.
  * 참고 - https://velog.io/@gooreum_90/SRP%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99
- OCP(Open Close Principle) (p.48) - 소프트웨어 엔티티(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하지만 변경에 대해서는 닫혀 있어야 한다. 즉, 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀 있어야 한다는 것이다. 이것은 interface를 통해 구현하여 해결한다.

- 추상 팩토리(ABSTRACT FACTRORY) (p.48) : 서로 관련이 있는 객체들을 묶어 팩토리 클래스로 만들고, 팩토리를 조건에 따라 생성하도록 다시 팩토리를 만들어서 객체를 생성하는 패턴?
  * 참고 - https://victorydntmd.tistory.com/300

- 때로는 예상치 못하게 클래스 변수를 수정한다. 때로는 함수로 넘어온 인수나 시스템 전역 변수를 수정한다. 어느 쪽이든 교활하고 해로운 거짓말이다. 많은 경우 시간적인 결합이나 순서 종속성을 초래한다. (p.55)
  - 시간적인 결합(temporal coupling)  - 시간을 수반하는 프로그램 또는 시스템 구성 요소 사이의 다양한 의존성을 의미. 시간 측면에서의 결합.  
  - 순서 종속성(order dependency) - https://docs.oracle.com/cd/E19120-01/open.solaris/819-0690/chapter4-49986/index.html  
  -> 메서드는 언제나 반드시 메서드 B보다 먼저 호출해야 한다. 보고서는 한 번에 오직 하나만 실행될 수 있다. 버튼 클릭을 처리하려면 먼저 화면이 갱신되어야 한다.

- 의존성 자석(magnet) : 붙이기는 쉬운데 떼어낼려면 고생해야 한다는 뜻. 많은 곳에서 참조하는 어떤 구조.
