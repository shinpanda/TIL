# 📝 TIL (2022.03.05 ~ 2022.03.06)  
## DAY 16
📖 오늘 읽은 범위 : 8장. 경계 ~ 9장. 단위 테스트
--- 
> 😄 **책에서 기억하고 싶은 내용을 써보세요.**  

### 8장. 경계
*외부 코드를 우리 코드에 깔끔하게 통합해야 할 때 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교를 살펴본다.*

- #### 외부코드 사용하기
  - 패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 애쓴다. 반면, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다.
  - java.util.Map
    - clear() 메서드를 제공함으로써 Map 사용자라면 누구나 Map 내용을 지울 권한이 있다.
    - Map은 객체 유형을 제한하지 않는다. 사용자는 어떤 객체 유형도 추가할 수 있다.
    - Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다. Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.
    - Map 클래스를 사용할 때 캡슐화 하는 법
    ```java
      public class Sensors{
        private Map sensors = new HashMap();

        public Sensor getById(String id){
          return (Sensor) sensors.get(id);
        }
      }
    ```
- #### 경계 살피고 익히기
  - 우리 자신을 위해 우리가 사용할 코드를 테스트하는 편이 바람직하다.
  - 짐 뉴커크*Jim Newkirk* **학습 테스트**
    - 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 방법
    - 프로그램에서 사용하려는 방식대로 외부 API를 호출한다. 통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다.
학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다.

- #### 학습 테스트틑 공짜 이상이다.
  - 필요한 지식만 확보하는 손쉬운 방법이다. 학습 테스트는 이해도를 높여주는 정확한 실험이다.
  - 투자하는 노력보다 얻는 성과가 더 크다. 패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.
  - 학습 테스트를 이용한 학습이 필요하든 그렇지 않든, 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다. 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다.
그렇지 않다면 낡은 버전을 필요 이상으로 사용하려는 유혹에 빠지기 쉽다.

- #### 아직 존재하지 않는 코드를 사용하기
  - 아는 코드와 모르는 코드를 분리하는 경계
  - 구현이 진행되기 전 Transmitter라는 인터페이스를 구현한 후 Fake Transmitter를 만들어 개발을 진행 후 API가 진행되었을 때 ADAPTER 패턴으로 API 사용을 캡슐화해 API가 바뀔 떄 수정할 코드를 한곳으로 모았다.

- #### 깨끗한 경계
  - 경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다.
통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다. 자칫하면 오히려 외부 코드에 휘둘리고 만다.
  - 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자. Map에서 봤듯이, 새로운 클래스로 경계를 감싸거나 아니면 ADAPTER 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자.
어느 방법이든 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지며, 외부 패키지가 변했을 때 변경할 코드도 줄어든다.

### 9장. 단위 테스트
- #### TDD(Test Driven Development) 법칙 세가지
  1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
  2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
  3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.
- #### 깨끗한 테스트 코드 유지하기
  - 실제 코드가 진화하면 테스트 코드도 변해야 한다. 그런데 테스트 코드가 지저분할수록 변경하기 어려워진다. 테스트 코드가 복잡할수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸리기 십상이다. 실제 코드를 변경해 기존 테스트 케이스가 실패하기 시작하면, 지저분한 코드로 인해, 실패하는 테스트 케이스를 점점 더 통과시키기 어려워진다. 그래서 테스트 코드는 계속해서 늘어나는 부담이 되버린다.
  - 테스트 슈트가 없으면 개발자는 자신이 수정한 코드가 제대로 도는지 확인할 방법이 없다. 테스트 슈트가 없으면 시스템 이쪽을 수정해도 저쪽이 안전하다는 사실을 검증하지 못한다. 그래서 결함율이 높아지기 시작한다. 의도하지 않은 결함 수가 많아지면 개발자는 변경을 주저한다. 변경하면 득보다 해가 크다 생각해 더 이상 코드를 정리하지 않는다. 그러면서 코드가 망가지기 시작한다.
  - `테스트 코드는 실제 코드 못지 않게 중요하다.` 테스트 코드는 이류 시민이 아니다. 테스트 코드는 사고와 설계와 주의가 필요하다. 실제 코드 못지 않게 깨끗하게 짜야 한다.
- #### 테스트는 유연성, 유지보수성, 재사용성을 제공한다.
  - 테스트 케이스가 없으면 실제 코드를 유연하게 만드는 버팀목도 사라진다. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 단위 테스트다.
  - 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 아키텍처가 아무리 유연하더라도, 설계를 아무리 잘 나눴더라도, 테스트 케이스가 없으면 개발자는 변경을 주저한다. 버그가 숨어들까 두렵기 때문이다.
  - 테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어지며 코드 구조를 개선하는 능력도 떨어진다. 테스트 코드가 지저분할수록 실제 코드도 지저분해진다. 결국 테스트 코드를 잃어버리고 실제 코드도 망가진다.
- #### 깨끗한 테스트 코드
  - 깨끗한 테스트 코드를 만들려면? 세 가지가 필요하다. 가독성, 가독성, 가독성.
  - 가독성을 높이려면? 여느 코드와 마찬가지다. 명료성, 단순성, 풍부한 표현력이 필요하다.
- #### 도메인에 특화된 테스트 언어
  - 도메인에 특화된 언어(DSL)로 테스트 코드를 구현.
  - 시스템 조작 API를 사용하는 대신 API 위에다 함수와 유틸리티를 구현한 후 그 함수와 유틸리티를 사용하므로 테스트 코드를 짜기도 읽기도 쉬워진다.
  - 숙련된 개발자라면 자기 코드를 좀 더 간결하고 표현력이 풍부한 코드로 리팩터링해야 마땅하다.
- #### 이중 표준
  - 테스트 API 코드에 적용하는 표준은 실제 코드에 적용하는 표준과 확실히 다르다. 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다.
  - 다음 코드는 효율을 높이려면 StringBuffer가 더 적합하다. StringBuffer는 보기에 흉하다. 이를 사용하지 않고 실시간 임베디드 시스템이라면, 컴퓨터 자원과 메모리가 제한적일 가능성이 높다. 하지만 테스트 환경은 자원이 제한적일 가능성이 낮다.
  ```java
    public String getState(){
      String state = "";
      state += heater ? "H" : "h";
      state += blower ? "B" : "b";
      state += cooler ? "C" : "c";
      state += hiTempAlarm ? "H" : "h";
      state += loTempAlarm ? "L" : "l";
      return state;
    }
  ```
  - 이것이 이준 표준의 본질이다. 실제 환경에서는 절대로 안 되지만 테스트 환경에서는 전혀 문제없는 방식이 있다. 대개 메모리나 CPU 효율과 관련 있는 경우다. 코드의 깨끗함과는 철저히 무관하다.
- #### 테스트 당 assert 하나
  - assert문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다.
  - 만약 "출력이 XML이다"라는 assert문과 "특정 문자열을 포함한다"는 assert문으로 검증해야 한다면 위 방식은 테스트를 쪼개 각자 assert문으로 수행해야 한다.  
이는 `TEMPLATE METHOD 패턴`을 사용하면 중복을 제거할 수 있다. given/when 부분을 부모 클래스에 두고 tehn 부분을 자식 클래스에 두면 된다. 아니면 독자적인 테스트 클래스를 만ㄷ르어 @Before 함수에 given/when 부분을 넣고 @Test 함수에 then 부분을 넣어도 된다. 하지만 모두가 배보다 배꼽이 더 크다. 이것저것 감안해 보면 assert 문을 여럿 사용하는 편이 좋다고 생각한다.  
  - 대체로 단일 assert문을 지원하는 해당 분야 테스트 언어를 만들려 노력한다. 하지만 때로는 주저 없이 함수 하나에 여러 assert문을 넣기도 한다. 단지 assert문 개수는 최대한 줄여야 좋다는 생각이다.
- #### 테스트 당 개념 하나
  - "테스트 함수마다 한 개념만 테스트하라"

> "개념 당 assert 문 수를 최소로 줄여라", "테스트 함수 하나는 개념 하나만 테스틀하라"

- #### F.I.R.S.T
  - Fast(빠르게) : 테스트는 빨라야 한다.
  - Independent(독립적으로) : 각 테스트는 서로 의존하면 안 된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안 된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행될 환경을 준비해서는 안 된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다. 테스트가 서로에게 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지며 후반 테스트가 찾아내야 할 결함이 숨겨진다.
  - Repeatable(반복가능하게) : 테스트는 어떤 환경(네트워크에 연결되지 않은)에서도 반복 가능해야 한다.
  - Self-Validationg(자가검증하는) : 테스트틑 bool 값으로 결과를 내야 한다.
  - Timely(적시에) : 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다.

- #### 결론
  - 테스트 코드는 지속적으로 깨끗하게 관리하자. 표현력을 높이고 간결하게 정리하자. 
  - 테스트 API를 구현해 도메인 특화 언어(Domain Specific Language, DSL)를 만들자. 그러면 그만큼 테스트 코드를 짜기가 쉬워진다.

> 🤔 **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**  
- 8장을 읽으면서 든 생각 : 고칠 게 많다..ㅎ...
- 9장을 읽으면서 든 생각 : 사실 단위 테스트를 컨퍼런스나 이제 이직을 하기 위해 과제를 수행하면서 처음으로 접하게 되었다.  
처음 자바 프로젝트를 나갔을 때 한 연동 시스템에서 처음 Junit을 사용하여 테스트를 진행하는 모습을 봤었는데 뭘 하는지 몰랐다. 그냥 테스트를 하는 건가 했다. 이제야 저렇게 개발하면 자신이 원하는 기능대로 동작하는 API를 만들 수있고, 이후 하나의 기능을 수정할 때 다른 기능이 정상적으로 동작하는지 의심하고 다시 테스트를 진행하지 않아도 되겠구나 라는 걸 깨달았다.  
프로젝트를 나갈 때 정상적으로 동작하는지 기능 테스트를 손으로 하고, 단위 테스트, 통합 테스트도 내가 그 단계를 작성하고 일일이 확인하는 작업을 했었는데 이 개념을 접하고 얼마나 시간을 소모하는 일이었는지 알게 되었다. 그래서 더 단위 테스트의 필요성을 느꼈다. 기존 제품을 믿지 못해 개발자가 프로젝트를 나가자마자 다시 테스트를 진행하여 오류를 제보하는 꼴이라니. 우숩고 민망한 일이 아닐 수 없다. 테스트 코드를 어떻게 짜야하는지 모른다고, 시간이 너무 오래 걸릴 것 같다고 포기하고 수정하지 않았던 것이 너무나도 잘못된 일이었음을 깨닫는다.  
계속해서 테스트 코드의 도입을 말하지 않고 있었지만 TDD를 알게 되면서 그 누구보다 우리 제품에 필요하지 않을까 하는 생각이 들었다.  
TDD를 제대로 알고 BDD, DDD 등의 개념을 익히고 각 케이스의 이점을 확인한 후 이 장에서 말한 것처럼 더러운 테스트 코드를 짜지 않도록 노력해야할 것 같다. 아직 나는 TDD가 익숙하지 않고 이전 짠 테스트 코드가 잘못되었음을 이 장을 읽으면서 깨달았다.

> 🔎 **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**  
- 제네릭스(Generices) : 다양한 타입의 객체를 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time type check)를 해주는 기능이다. 제네릭 타입은 클래스와 메서드에 선언할 수 있다.
-> 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성이 높아지고, 형변환의 번거로움이 줄어든다.
  ```java
  	Box<T> // 제네릭 클래스. T Box라고 읽는다.
    T // 타입 변수 또는 타입 매개변수
    Box // 원시 타입(raw type)
  ```
  - 참고 : https://developer-alle.tistory.com/216
- ADAPTER 패턴 : 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해준다.
  - 참고 : https://jusungpark.tistory.com/22
- 테스트 슈트 : 테스트 유닛의 집합 (일반적으로 함수 묶음)
  -  테스트 유닛 : 테스트를 하는 단위 기능(일반적으로 함수)
- DSL : 특정한 도메인(산업, 분야 등 특정 영역)에서 발생하는 문제점을 해결하는 것에 중점을 두고 도메인을 기준으로 모든 것을 풀어나가기 위해 제공되는 언어
- BUILD-OPERATE-CHECK 패턴 
  - 참고 : https://medium.com/swlh/usual-production-patterns-applied-to-integration-tests-50a941f0b04a
  ![](https://miro.medium.com/max/630/1*YslDrfj6TUWlQvaUoC3xXQ.jpeg)
  - Build : 테스트 시나리오를 준비하는 단계. 일반적으로 일부 데이터를 데이터베이스에 저장한다.
  - Operate : 테스트할 객체 또는 API의 메서드를 실행하는 단계
  - Check : 실행된 메서드가 시스템에 예상된 영향을 미쳤는지 확인하는 단계. 일반적으로, 데이터베이스에 질의하고 메서드 실행 결과를 확인한다.
- TEMPLATE METHOD 패턴 : 어떤 기능 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계의 수행 내역을 바꾸는 패턴
  - 참고 : https://kyeoneee.tistory.com/64
