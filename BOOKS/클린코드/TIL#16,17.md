# 📝 TIL (2022.03.05 ~ 2022.03.06)  
## DAY 16
📖 오늘 읽은 범위 : 8장. 경계 ~ 9장. 단위 테스트
--- 
> 😄 **책에서 기억하고 싶은 내용을 써보세요.**  

### 8장. 경계
*외부 코드를 우리 코드에 깔끔하게 통합해야 할 때 소프트웨어 경계를 깔끔하게 처리하는 기법과 기교를 살펴본다.*

- #### 외부코드 사용하기
  - 패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 애쓴다. 반면, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다.
  - java.util.Map
    - clear() 메서드를 제공함으로써 Map 사용자라면 누구나 Map 내용을 지울 권한이 있다.
    - Map은 객체 유형을 제한하지 않는다. 사용자는 어떤 객체 유형도 추가할 수 있다.
    - Map과 같은 경계 인터페이스를 이용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다. Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다.
    - Map 클래스를 사용할 때 캡슐화 하는 법
    ```java
      public class Sensors{
        private Map sensors = new HashMap();

        public Sensor getById(String id){
          return (Sensor) sensors.get(id);
        }
      }
    ```
- ####경계 살피고 익히기
  - 우리 자신을 위해 우리가 사용할 코드를 테스트하는 편이 바람직하다.
  - 짐 뉴커크*Jim Newkirk* **학습 테스트**
    - 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히는 방법
    - 프로그램에서 사용하려는 방식대로 외부 API를 호출한다. 통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다.
학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다.

- #### 학습 테스트틑 공짜 이상이다.
  - 필요한 지식만 확보하는 손쉬운 방법이다. 학습 테스트는 이해도를 높여주는 정확한 실험이다.
  - 투자하는 노력보다 얻는 성과가 더 크다. 패키지 새 버전이 나온다면 학습 테스트를 돌려 차이가 있는지 확인한다.
  - 학습 테스트를 이용한 학습이 필요하든 그렇지 않든, 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다. 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다.
그렇지 않다면 낡은 버전을 필요 이상으로 사용하려는 유혹에 빠지기 쉽다.

- #### 아직 존재하지 않는 코드를 사용하기
  - 아는 코드와 모르는 코드를 분리하는 경계
  - 구현이 진행되기 전 Transmitter라는 인터페이스를 구현한 후 Fake Transmitter를 만들어 개발을 진행 후 API가 진행되었을 때 ADAPTER 패턴으로 API 사용을 캡슐화해 API가 바뀔 떄 수정할 코드를 한곳으로 모았다.

- #### 깨끗한 경계
  - 경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다.
통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다. 자칫하면 오히려 외부 코드에 휘둘리고 만다.
  - 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자. Map에서 봤듯이, 새로운 클래스로 경계를 감싸거나 아니면 ADAPTER 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자.
어느 방법이든 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지며, 외부 패키지가 변했을 때 변경할 코드도 줄어든다.


> 🤔 **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**  
- 고칠 게 많다..ㅎ...

> 🔎 **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**  
- 제네릭스(Generices) : 다양한 타입의 객체를 다루는 메서드나 컬렉션 클래스에 컴파일 시의 타입 체크(compile-time type check)를 해주는 기능이다. 제네릭 타입은 클래스와 메서드에 선언할 수 있다.
-> 객체의 타입을 컴파일 시에 체크하기 때문에 객체의 타입 안정성이 높아지고, 형변환의 번거로움이 줄어든다.
  ```java
  	Box<T> // 제네릭 클래스. T Box라고 읽는다.
    T // 타입 변수 또는 타입 매개변수
    Box // 원시 타입(raw type)
  ```
  - 참고 : https://developer-alle.tistory.com/216
- ADAPTER 패턴 : 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴으로, 호환성이 없는 인터페이스 때문에 함께 동작할 수 없는 클래스들이 함께 작동하도록 해준다.
  - 참고 : https://jusungpark.tistory.com/22
