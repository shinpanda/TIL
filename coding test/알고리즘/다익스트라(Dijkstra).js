// 최단 경로 탐색 알고리즘

// 최단 거리는 여러 개의 최단 거리로 이루어져있기 때문이다.
// 하나의 최단 거리를 구할 때 그 이전까지 구했던 최단 거리 정보를 그대로 사용한다는 특징을 가진다.

// 현재까지 알고있던 최단 경로를 계속해서 갱신

// 1. 출발 노드를 설정
// 2. 출발 노드를 기준으로 각 노드의 최소 비용을 저장
// 3. 방문하지 않은 노드 중에서 가장 비용이 적은 노드를 선택
// 4. 해당 노드를 거쳐 특정한 노드로 가는 경우를 고려하여 최소 비용을 갱신
// 5. 위 3~4 과정을 반복한다

// => 2차원 배열로 처리

// 1차원으로 비용 계산

const number = 6;

// 간선정보
let a = [
  [],
  [[2, 2], [3, 5][(4, 1)]],
  [
    [1, 2],
    [3, 3],
    [4, 2],
  ],
  [
    [1, 5],
    [2, 3],
    [4, 3],
    [5, 1],
    [6, 5],
  ],
  [
    [1, 1],
    [2, 2],
    [3, 3],
    [5, 1],
  ],
  [
    [3, 1],
    [4, 1],
    [6, 2],
  ],
  [
    [3, 5],
    [5, 2],
  ],
];

let d = Array.from({ length: number + 1 }, (_, i) => i);

const dijkstra = (start) => {
  d[start] = 0;
  const queue = new MaxPriorityQueue();
  queue.enqueue([start, 0]);
  while (!queue.empty) {}
};
